%{
#include <stdio.h>
#include <string>
#include <vector>
#include <stack>

#define RESET		0
#define BRIGHT 		1
#define DIM		2
#define UNDERLINE 	3
#define BLINK		4
#define REVERSE		7
#define HIDDEN		8

#define BLACK 		0
#define RED		1
#define GREEN		2
#define YELLOW		3
#define BLUE		4
#define MAGENTA		5
#define CYAN		6
#define	WHITE		7

using namespace std;
extern FILE* yyin;
extern FILE* yylogfile;
extern FILE* yyerrorfile;
extern FILE *yyout;
extern int yyparse(void);
extern char* yytext;
extern int _allOkFlag;
extern string _programDescription; 
extern string _tempBuff;
extern int yylineno;
extern int yyval;

/*
extern struct MyObject;
extern struct dataType;

extern vector<string> dataTypes;
extern stack<string> encounteredStrings;
*/

int yylex(void);
void yyerror(const char *);
void Log(char *);
void Log(char * prepend, int d);
void Log(char * prepend, char * s);
void textcolor(int attr, int fg, int bg);
%}
%token TEXT NUME INTEGER STRING
%token ACVILA_BEGIN ACVILA_END HEAD_BEGIN HEAD_END BODY_BEGIN BODY_END 
%token STRUCT_BEGIN STRUCT_END CAMP_START DEFINES_START DEFINES_END CONSTANTA_START

%token SMALLER_THAN BIGGER_THAN SINGLETAG_END VAR_START
%token GE LE EQ NE PLUS MINUS MUL DEVIDE OR AND NOT
%token VARIABLE_DELIMITER FUNCTION_DELIMITER DOUA_PUNCTE
%token FUNCTION_START FUNCTION_END PARAM_START CLASS_START CLASS_END
%token OPEN_PARAN CLOSE_PARAN COMMA TILDA UNDERSCORE
%token TRY ENDWITH VISIBLE NONVISIBLE INCLUDE

%token IF_START IF_END WHILE_START WHILE_END FOR_START FOR_END ELSE PRINT TIP

%left GE LE EQ NE SMALLER_THAN BIGGER_THAN
%left PLUS MINUS
%left MUL DIVIDE
%left OR AND
%left NOT
%nonassoc PMINUS

%start program
%%
program: ACVILA_BEGIN innerprogram ACVILA_END
	| error ACVILA_BEGIN inclusions innerprogram ACVILA_END {yyerror("Error in program");}
     ;
inclusions: 
	inclusion inclusions
	| ;
inclusion:
	INCLUDE STRING;
	
	
	
innerprogram:  head theprogram;
head:
	HEAD_BEGIN HEAD_END 
		{
			if (_programDescription.size())
			{	
				printf("\nProgram description:\n");
				textcolor(BRIGHT, GREEN, BLACK);
				printf("%s", (char *)_programDescription.data());
				textcolor(RESET, WHITE, BLACK);	
			}
			else
			{
				textcolor(BRIGHT, BLUE, BLACK);	
				printf("\nNo description\n");
				textcolor(RESET, WHITE, BLACK);
			}
			Log("Header description", (char *)_programDescription.data());
		} 
	| error BODY_BEGIN {yyerror("Error in header");}
	|
	;
theprogram: 
		BODY_BEGIN stuffToDo BODY_END;
	|	error stuffToDo {yyerror("Error in body");}
stuffToDo:
	smth stuffToDo {$$ = $2 + $1;}
	| ;
smth:
		structura_date		
	|	class_declaration
	|	define_constants
	|	single_declaration
	|	single_declaration2
	|	list_declaration
	|	function_declaration
	|	while
	|	for
	|	if
	|	expression 
	|	error stuffToDo {yyerror("Error on parsing element");}
	;
	
restrictedStuffToDo:
	restrictedSmth stuffToDo {$$ = $2 + $1;}
	| ;
	
restrictedSmth:
		list_declaration
	|	function_declaration
	|	while
	|	for
	|	if
	|	expression 
	|	error stuffToDo {yyerror("Error on parsing element");}

	
class_toDo:
	class_smth class_toDo {$$ = $2 + $1;}
	| error CLASS_END {yyerror("Error in class contents");}
	| ;

class_smth:
		structura_date		
	|	class_declaration
	|	define_constants
	|	single_declaration
	|	single_declaration2
	|	list_declaration
	|	function_declaration
	|	error class_toDo {yyerror("Error on parsing element");}
	;

	
expression: INTEGER
		|	Variable
		|	Constant
		|	STRING
		|	function_call
		|	array_list
		|	MINUS expression %prec PMINUS
		|	expression PLUS expression
		|	expression PLUS PLUS
		|	expression MINUS expression
		|	expression MINUS MINUS
		|	expression MUL expression
		|	expression DIVIDE expression
		|	expression BIGGER_THAN expression
		|	expression BIGGER_THAN BIGGER_THAN INTEGER
		|	expression SMALLER_THAN expression
		|	expression SMALLER_THAN SMALLER_THAN INTEGER
		|	expression GE expression
		|	expression LE expression
		|	expression NE expression
		|	expression EQ expression
		|   NOT expression 
		|	expression AND expression
		|	expression OR expression
		|	expression AND AND expression
		|	expression OR OR expression
		|	OPEN_PARAN expression CLOSE_PARAN
		|	error stuffToDo {yyerror("Error on parsing expression");}
		;

Variable: 
		VARIABLE_DELIMITER NUME;
	|	VARIABLE_DELIMITER NUME UNDERSCORE Variable;
	|	VARIABLE_DELIMITER NUME array_use;
	|	VARIABLE_DELIMITER NUME array_use UNDERSCORE Variable;
Constant: DOUA_PUNCTE NUME DOUA_PUNCTE;
array_list: 
		TILDA TILDA
	|	TILDA INTEGER integer_list TILDA
	| 	TILDA STRING string_list TILDA
	|	error TILDA {yyerror("Array list error");}
	;
integer_list: 
		COMMA INTEGER integer_list
	| ;
string_list: 
		COMMA STRING string_list
	| ;
		


class_declaration:
	CLASS_START NUME BIGGER_THAN class_toDo CLASS_END
	| error CLASS_END {yyerror("Error in class declaration");}
	;

while:
	WHILE_START expression BIGGER_THAN restrictedStuffToDo WHILE_END
	| error WHILE_END {yyerror("\"While\" error");}
	;
for:
		FOR_START expression TRY expression ENDWITH expression BIGGER_THAN restrictedStuffToDo FOR_END
	|	FOR_START TRY expression ENDWITH expression BIGGER_THAN restrictedStuffToDo FOR_END
	|	FOR_START TRY expression BIGGER_THAN restrictedStuffToDo FOR_END
	| 	error FOR_END {yyerror("\"FOR\" error");}
	;
if:
		IF_START expression BIGGER_THAN stuffToDo IF_END;
	|	IF_START expression BIGGER_THAN stuffToDo ELSE stuffToDo IF_END
	|	error IF_END {yyerror("\"IF\" Error");}
	;
	

	
	
	
	
	
	
single_declaration: 
			TIP VARIABLE_DELIMITER NUME {$$ = $1 + $3;}
		|	TIP VARIABLE_DELIMITER NUME array_use {$$ = $1 + $3;}
		| 	TIP VARIABLE_DELIMITER NUME EQ expression
		| 	TIP VARIABLE_DELIMITER NUME array_use EQ expression
		| 	error STRUCT_END {yyerror("Bad variable declaration");}
		;
single_declaration2:
			VAR_START single_declaration SINGLETAG_END
		|	VAR_START single_declaration VISIBLE SINGLETAG_END
		|	VAR_START single_declaration NONVISIBLE SINGLETAG_END
		;
list_declaration: TIP VARIABLE_DELIMITER NUME list_declaration_continue;
list_declaration_continue: "," NUME list_declaration_continue | "," NUME;
array_use:
			TILDA INTEGER TILDA;






function_declaration: 
			FUNCTION_START single_declaration BIGGER_THAN function_params stuffToDo FUNCTION_END
		|	error FUNCTION_END {yyerror("Function declaration error");}
function_params:
		param function_params {$$ = 1 + $2;}
		| {$$ = 1;}
		;
param: 
		PARAM_START single_declaration SINGLETAG_END;
	
	
	
	
function_call:
			FUNCTION_DELIMITER NUME OPEN_PARAN function_arguments CLOSE_PARAN
		|	error CLOSE_PARAN {yyerror("Function call error");}
function_arguments:
			expression function_arguments_list
			| expression
			| ;
function_arguments_list:
			COMMA expression function_arguments_list
			| ;
	
	
	
	
	
	
	
structura_date:	
		STRUCT_BEGIN NUME BIGGER_THAN campuri_struct STRUCT_END
		{
			$$ = $4;
			Log ("Nr de element in struct: ", $4);
		}
		| 	error STRUCT_END {yyerror("Struct error");}
		;
campuri_struct: 
		camp campuri_struct {$$ = 1 + $2;}
		| {$$ = 1;};
camp: 
		CAMP_START single_declaration SINGLETAG_END;
		
		

define_constants:
		DEFINES_START constante_declare DEFINES_END
		{
			$$ = $2;
			Log ("Nr de constante in defines: ", $2);
		}
		|	error DEFINES_END {yyerror("Defines error");}
		;
constante_declare:
		constanta_declare constante_declare {$$ = 1 + $2;}
		| {$$ = 0;};
constanta_declare:
		CONSTANTA_START single_declaration expression SINGLETAG_END;
%%

void yyerror( const char * s)
{
	_allOkFlag = 0;
	printf("eroare: %s la linia:%d\n",s,yylineno);
	fprintf(yyerrorfile, "eroare: %s la linia:%d\n",s,yylineno);
}

void Log(char * s)
{
	fprintf(yylogfile, "\n%s", s);
}

void Log(char * prepend, char * s)
{
	fprintf(yylogfile, "\n%s: %s", prepend, s);
}

void Log(char * prepend, int d)
{
	fprintf(yylogfile, "\nLineNo.%d - %s: %d", yylineno, prepend, d);
}

void textcolor(int attr, int fg, int bg)
{	char command[13];

	/* Command is the control command to the terminal */
	sprintf(command, "%c[%d;%d;%dm", 0x1B, attr, fg + 30, bg + 40);
	printf("%s", command);
}

int main(int argc, char** argv)
{
	_allOkFlag = 1;
	yyin=fopen(argv[1],"r");
	yylogfile = fopen("acvilaCompilerLog.log", "w");
	yyerrorfile = fopen("acvilaCompilerError.log", "w");
	yyparse();
	if (_allOkFlag)
	{
		textcolor(BRIGHT, WHITE, BLACK);
		printf("\nProgram OK! Revise log for information.\n");
		textcolor(RESET, WHITE, BLACK);
	}
	else
	{
		textcolor(BLINK, RED, BLACK);
		printf("\n\nThere were sintax errors!\n");
		textcolor(RESET, WHITE, BLACK);
	}
} 